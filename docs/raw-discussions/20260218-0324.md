Good call.

A formal spec alone is sterile.
Your README needs **intent**, not just rules.

Below is a narrative/concept document you can prepend to the formal POS spec.
It explains the philosophy, scope, and why decisions were made — without bloating tokens.

---

# POS Bounded Context – Concept & Philosophy

## 1. What POS Is

The POS (Point of Sale) bounded context is the **operational execution layer of retail transactions**.

It is responsible for:

* Managing terminals
* Managing cashier shifts
* Managing POS sessions
* Coordinating order creation
* Transitioning orders from draft to committed
* Orchestrating payment requests
* Tracking operational cash drawer state

POS is not an accounting system.
POS is not an inventory system.
POS is not an order calculation engine.

POS is the **interaction and operational control domain** of brick-and-mortar retail.

---

## 2. Core Philosophy

### 2.1 Separation of Commitment

Retail transactions have two distinct phases:

**Soft commitment (Draft)**

* Items are scanned
* Inventory is softly reserved
* Order may expire

**Hard commitment (Checkout / Confirmed)**

* Order is confirmed
* Reservation becomes hard
* No automatic expiration
* Explicit cancellation required

This separation ensures:

* Operational flexibility during scanning
* Financial discipline once checkout begins
* Deterministic behavior across terminals

---

### 2.2 POS Is a Real Domain

POS is not a thin UI wrapper.

It has its own domain model:

* Terminal lifecycle
* Shift lifecycle
* Session lifecycle
* Cash handling rules
* Reservation timing policies
* Checkout boundary enforcement

This makes POS a first-class bounded context within the retail OS.

---

### 2.3 POS Does Not Own Business Truth

POS never owns:

* Price calculation
* Tax computation
* Inventory deduction
* Payment processing
* Revenue recognition

It orchestrates.
It does not calculate.
It does not post.

Business truth belongs to:

* Ordering BC
* Inventory BC
* Payment BC
* Financial BC

POS only coordinates their usage in real time.

---

## 3. Operational Discipline Over Automation

The system is designed with the assumption that:

* Humans make mistakes
* Hardware fails
* Internet may drop
* Busy seasons cause stress

Therefore:

* Nothing critical auto-deletes
* Post-payment orders never auto-expire
* Confirmed orders require explicit resolution
* Shift close blocks unresolved commitments
* Cash variance is recorded, not silently corrected

Where automation becomes dangerous,
manual intervention is allowed and logged.

---

## 4. Multi-Terminal Retail Reality

The system assumes:

* Multiple terminals per branch
* Concurrent selling
* Shared inventory pool
* Independent shifts

Therefore:

* Inventory is server-authoritative
* Reservations occur at draft stage
* Reservation converts to hard at checkout
* Conflicts fail fast
* Draft restoration is terminal-bound

Concurrency safety is prioritized over UI convenience.

---

## 5. Checkout as Commitment Boundary

In this design:

Checkout = Order Confirmation.

Once checkout is triggered:

* Cart is locked
* Reservation becomes hard
* TTL stops
* Explicit cancel required

This prevents ambiguous “half-committed” states.

There is no limbo state between draft and confirmed.

---

## 6. Payment as External Authority

POS only receives:

* OK
* NOT OK

from the Payment BC.

POS never:

* Stores authorization logic
* Handles gateway retries
* Computes capture state

This keeps payment logic isolated and replaceable.

---

## 7. Cash Drawer Is Operational, Not Financial

POS tracks:

* Opening float
* Cash payments
* Cash refunds
* Cash drops
* Closing declaration
* Variance

It does not:

* Post accounting entries
* Record expenses
* Perform reconciliation

Cash handling is operational.
Accounting is external.

---

## 8. Explicit Boundaries Create Stability

Key invariants:

* One cashier = one terminal per shift
* One terminal = one open shift
* Shift cannot close with unresolved orders
* Draft may expire
* Confirmed never auto-expires
* Inventory deducts only on completion
* No expense withdrawals in POS

These invariants prevent state corruption.

---

## 9. Designed for Extension, Not Over-Engineering

The POS core intentionally excludes:

* Exchange workflows
* Advanced return logic
* Refund without return
* Layaway time policies
* Accounting reconciliation
* Cross-terminal recovery

The architecture supports them,
but they are not part of the foundational scope.

The goal is:

Stability first.
Extensibility second.
Complexity later.

---

## 10. Architectural Position in Retail OS

```
POS BC
   ↳ uses Ordering BC
   ↳ uses Inventory BC
   ↳ uses Payment BC

Ordering, Inventory, Payment
   ↳ never depend on POS
```

This preserves modularity.

POS is an operational interface domain,
not a central business authority.

---

# Final Summary

The POS bounded context:

* Enforces operational discipline
* Protects transactional integrity
* Separates commitment phases
* Handles concurrency safely
* Tracks cash operationally
* Delegates business truth outward
* Avoids accounting contamination
* Supports multi-terminal scaling

It is designed to be:

Deterministic
Auditable
Concurrent-safe
Operationally realistic
Modular

---

If you want, I can now:

* Merge this narrative + formal spec into a single structured README layout
* Or produce a DDD-style domain model document (Aggregates / Commands / Events / Policies) ready for your AI dev to implement in your Laravel + ES stack.

================================================================================

Perfect. Below is a **clean, comprehensive, implementation-ready POS specification** focused strictly on the POS Bounded Context.

It is structured for AI-dev consumption: clear scope, rules, invariants, states, and boundaries — without unnecessary narrative.

---

# STOREBUNK – POS BOUNDED CONTEXT SPECIFICATION

## 1. Purpose

POS is an operational bounded context responsible for:

* Terminal lifecycle
* Cashier shift lifecycle
* POS session lifecycle
* Draft order management
* Checkout confirmation trigger
* Reservation mode transition (soft → hard)
* Payment orchestration (delegation only)
* Cash drawer operational tracking
* Multi-terminal enforcement
* Shift accountability rules

POS does NOT:

* Compute totals
* Compute taxes
* Process payments
* Deduct inventory
* Post financial entries
* Perform accounting reconciliation

---

# 2. Context Boundaries

## POS Depends On:

* Ordering BC (SalesOrder aggregate)
* Inventory BC (reservation handling)
* Payment BC (authorization/capture)
* Authentication/Identity BC

## POS Does NOT Own:

* Order pricing logic
* Inventory stock logic
* Payment processing
* Ledger posting

Dependency direction is strictly one-way:

```
POS → Ordering
POS → Inventory
POS → Payment
```

---

# 3. Core Aggregates

## 3.1 Terminal (Entity)

Represents a registered POS device.

Fields:

* terminalId
* branchId
* status (Active | Disabled | Maintenance)
* registeredAt

Rules:

* Terminal belongs to exactly one branch.
* Terminal can have only one open shift at a time.

---

## 3.2 Shift (Aggregate Root)

Represents a cashier working session on a terminal.

Fields:

* shiftId
* terminalId
* branchId
* cashierId
* openedAt
* closedAt
* status (Open | Closed | ForcedClosed)
* openingCashAmount
* declaredClosingCashAmount (nullable until close)
* expectedCashAmount (derived)
* varianceAmount (derived)
* cashDrops[]

Rules:

* One cashier = one terminal per open shift.
* A cashier cannot open multiple shifts.
* A terminal cannot have multiple open shifts.
* Shift cannot close if:

  * Draft orders exist
  * Confirmed (not completed) orders exist

Force Close:

* Requires supervisor authorization.
* Does not auto-cancel Confirmed orders.
* Logs audit record.

---

## 3.3 PosSession (Aggregate Root)

Represents active UI lifecycle.

Fields:

* sessionId
* shiftId
* activeOrderId (nullable)
* parkedOrderIds[]
* state (Idle | Building | Checkout)

Rules:

* Session exists only while shift is open.
* Session does not own order data.
* Session only references orderId.
* Session ends when shift closes.

---

# 4. Order Lifecycle in POS Context

POS interacts with SalesOrder states:

## States Used by POS

* Draft (Active)
* Inactive (soft reservation expired)
* Confirmed (Checkout pressed; hard reservation)
* Completed
* Cancelled

---

# 5. Draft Phase (Soft Commitment)

Created when:

* Cashier starts new order.

Behavior:

* Items added directly to SalesOrder.
* Inventory reservation = SOFT (TTL applies).
* Draft inactivity TTL enforced.
* If TTL expires:

  * Reservation released
  * Order transitions to Inactive.

Inactive:

* Can be resumed ONLY by:

  * Same terminal
  * Same shift
* Resume attempts re-reserve all items atomically.
* If insufficient stock → alert cashier.

Auto Cancel:

* If inactive > 1 hour → Cancelled.

---

# 6. Checkout Phase (Hard Commitment)

Triggered when cashier presses "Checkout".

Effects:

* Order transitions Draft → Confirmed.
* Reservation becomes HARD.
* TTL disabled.
* Order no longer auto-expires.
* Cart modifications disabled.

After Checkout:

* No add/remove item.
* No price edits.
* No quantity edits.
* Explicit cancel required to reverse.

---

# 7. Confirmed / Partially Paid Orders

Once payment applied:

* Order is Confirmed.
* No TTL.
* Reservation persists.
* Order independent of session.

Allowed actions:

* Apply additional payment.
* Process return (future extension).

Not allowed:

* Editing lines.
* Editing price.
* Editing quantity.

Shift close must block if Confirmed but not Completed orders exist.

---

# 8. Payment Orchestration

POS responsibilities:

* Select payment method.
* Request authorization from Payment BC.
* Act on OK / NOT OK response only.

POS does NOT:

* Persist payment authorization logic.
* Retry payment internally.
* Handle gateway logic.

Flow:

1. POS → Payment BC (request)
2. Payment BC → OK / NOT OK
3. If OK → POS instructs SalesOrder.applyPayment()
4. If fully paid → POS triggers complete()

Manual intervention allowed if failure scenario occurs.

---

# 9. Inventory Reservation Model (POS Perspective)

Draft:

* Soft reservation (TTL enforced by Inventory BC).

Checkout:

* Convert soft → hard reservation.

Completed:

* Inventory BC deducts onHand.

Cancelled:

* Reservation released.

POS never manipulates stock directly.

---

# 10. Multi-Terminal Rules

* Multiple terminals per branch allowed.
* Inventory is branch-scoped.
* Reservation conflict:

  * If insufficient stock → addItem fails.
* Resume inactive order:

  * Only same terminal + same shift.

No cross-terminal draft restoration.

---

# 11. Cash Handling Model

POS handles operational drawer tracking only.

## Allowed Cash Movements:

* Opening cash
* Cash payments
* Cash refunds
* Cash drops
* Closing declaration

No expense withdrawals allowed.

---

## 11.1 Cash Drop

Fields:

* dropId
* shiftId
* amount
* performedBy
* approvedBy (if required)
* reason
* timestamp

Rules:

* Reduces drawer physical cash.
* Logged permanently.
* Cannot be edited or deleted.

---

## 11.2 Expected Cash Calculation

```
expectedCash =
    openingCash
  + totalCashPayments
  - totalCashRefunds
  - sum(cashDrops)
```

Derived from SalesOrder data + shift events.

---

## 11.3 Shift Close

On close:

1. Cashier enters counted cash.
2. System computes variance.
3. Records variance.
4. Emits ShiftClosed event.

No accounting posting occurs inside POS.

---

# 12. Offline Behavior

Allowed when:

* Draft creation
* Item scanning
* Cash-only completion (feature flag)

Not allowed when:

* Card payments
* External payment required

Offline orders marked as:

* PendingSync

Upon reconnection:

* Replay commands with idempotency keys.

---

# 13. Concurrency & Versioning

* All aggregates must use optimistic versioning.
* Commands must include unique commandId.
* Resume re-reservation must be atomic.
* Reservation expiration handled server-side only.

---

# 14. Invariants Summary

1. One cashier = one terminal per open shift.
2. One terminal = one open shift.
3. Shift cannot close if Draft or Confirmed orders exist.
4. Checkout locks order lines.
5. Payment cannot apply without Confirmed state.
6. Reservation TTL only applies in Draft.
7. Confirmed orders cannot auto-expire.
8. Cash drawer only affected by defined cash movements.
9. No expense withdrawal in POS.
10. POS never owns pricing, tax, stock deduction, or ledger logic.

---

# 15. Out of Scope (Future Extensions)

* Return workflows
* Exchange workflows
* Refund without return
* Cross-terminal order reopening
* Layaway policies
* Financial reconciliation
* Expense withdrawal
* Promotion override workflows

---

# 16. POS Event Emissions (High Level)

POS may emit:

* ShiftOpened
* ShiftClosed
* ShiftForceClosed
* CashDropRecorded
* CheckoutInitiated
* OrderCancelledViaPOS
* PaymentRequested

Ordering, Inventory, and Financial BCs react independently.

---

# FINAL STATUS

POS Bounded Context now includes:

* Terminal domain
* Shift domain
* Session domain
* Draft lifecycle enforcement
* Checkout hard-commit rule
* Payment orchestration boundary
* Reservation coordination
* Multi-terminal enforcement
* Operational cash tracking
* Clear accounting separation

This specification is stable and production-grade.

---

If you want next:

I can convert this into:

* A formal domain model (aggregate + command + event list)
* Or a developer-oriented implementation guide structured for your DDD + ES + Hexa stack.
